// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.15.8
// source: layer/goevent.proto

package layer

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EventLayerClient is the client API for EventLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventLayerClient interface {
	Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*EventList, error)
	GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Event, error)
	Edit(ctx context.Context, in *EventEditPayload, opts ...grpc.CallOption) (*Empty, error)
	Create(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error)
}

type eventLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventLayerClient(cc grpc.ClientConnInterface) EventLayerClient {
	return &eventLayerClient{cc}
}

func (c *eventLayerClient) Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*EventList, error) {
	out := new(EventList)
	err := c.cc.Invoke(ctx, "/layer.EventLayer/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := c.cc.Invoke(ctx, "/layer.EventLayer/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) Edit(ctx context.Context, in *EventEditPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.EventLayer/Edit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) Create(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.EventLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.EventLayer/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventLayerServer is the server API for EventLayer service.
// All implementations must embed UnimplementedEventLayerServer
// for forward compatibility
type EventLayerServer interface {
	Get(context.Context, *Pagination) (*EventList, error)
	GetByID(context.Context, *IDPayload) (*Event, error)
	Edit(context.Context, *EventEditPayload) (*Empty, error)
	Create(context.Context, *Event) (*Empty, error)
	Delete(context.Context, *IDPayload) (*Empty, error)
	mustEmbedUnimplementedEventLayerServer()
}

// UnimplementedEventLayerServer must be embedded to have forward compatible implementations.
type UnimplementedEventLayerServer struct {
}

func (UnimplementedEventLayerServer) Get(context.Context, *Pagination) (*EventList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedEventLayerServer) GetByID(context.Context, *IDPayload) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByID not implemented")
}
func (UnimplementedEventLayerServer) Edit(context.Context, *EventEditPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Edit not implemented")
}
func (UnimplementedEventLayerServer) Create(context.Context, *Event) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedEventLayerServer) Delete(context.Context, *IDPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedEventLayerServer) mustEmbedUnimplementedEventLayerServer() {}

// UnsafeEventLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventLayerServer will
// result in compilation errors.
type UnsafeEventLayerServer interface {
	mustEmbedUnimplementedEventLayerServer()
}

func RegisterEventLayerServer(s grpc.ServiceRegistrar, srv EventLayerServer) {
	s.RegisterService(&EventLayer_ServiceDesc, srv)
}

func _EventLayer_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.EventLayer/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).Get(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.EventLayer/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_Edit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventEditPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).Edit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.EventLayer/Edit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).Edit(ctx, req.(*EventEditPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.EventLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).Create(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.EventLayer/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).Delete(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

// EventLayer_ServiceDesc is the grpc.ServiceDesc for EventLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.EventLayer",
	HandlerType: (*EventLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _EventLayer_Get_Handler,
		},
		{
			MethodName: "GetByID",
			Handler:    _EventLayer_GetByID_Handler,
		},
		{
			MethodName: "Edit",
			Handler:    _EventLayer_Edit_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _EventLayer_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _EventLayer_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// ParticipantLayerClient is the client API for ParticipantLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParticipantLayerClient interface {
	Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*ParticipantList, error)
	TagByID(ctx context.Context, in *TagParticipantPayload, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error)
}

type participantLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewParticipantLayerClient(cc grpc.ClientConnInterface) ParticipantLayerClient {
	return &participantLayerClient{cc}
}

func (c *participantLayerClient) Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*ParticipantList, error) {
	out := new(ParticipantList)
	err := c.cc.Invoke(ctx, "/layer.ParticipantLayer/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantLayerClient) TagByID(ctx context.Context, in *TagParticipantPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.ParticipantLayer/TagByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantLayerClient) Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.ParticipantLayer/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParticipantLayerServer is the server API for ParticipantLayer service.
// All implementations must embed UnimplementedParticipantLayerServer
// for forward compatibility
type ParticipantLayerServer interface {
	Get(context.Context, *Pagination) (*ParticipantList, error)
	TagByID(context.Context, *TagParticipantPayload) (*Empty, error)
	Delete(context.Context, *IDPayload) (*Empty, error)
	mustEmbedUnimplementedParticipantLayerServer()
}

// UnimplementedParticipantLayerServer must be embedded to have forward compatible implementations.
type UnimplementedParticipantLayerServer struct {
}

func (UnimplementedParticipantLayerServer) Get(context.Context, *Pagination) (*ParticipantList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedParticipantLayerServer) TagByID(context.Context, *TagParticipantPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagByID not implemented")
}
func (UnimplementedParticipantLayerServer) Delete(context.Context, *IDPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedParticipantLayerServer) mustEmbedUnimplementedParticipantLayerServer() {}

// UnsafeParticipantLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParticipantLayerServer will
// result in compilation errors.
type UnsafeParticipantLayerServer interface {
	mustEmbedUnimplementedParticipantLayerServer()
}

func RegisterParticipantLayerServer(s grpc.ServiceRegistrar, srv ParticipantLayerServer) {
	s.RegisterService(&ParticipantLayer_ServiceDesc, srv)
}

func _ParticipantLayer_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantLayerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.ParticipantLayer/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantLayerServer).Get(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantLayer_TagByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagParticipantPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantLayerServer).TagByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.ParticipantLayer/TagByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantLayerServer).TagByID(ctx, req.(*TagParticipantPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantLayer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantLayerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.ParticipantLayer/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantLayerServer).Delete(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

// ParticipantLayer_ServiceDesc is the grpc.ServiceDesc for ParticipantLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ParticipantLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.ParticipantLayer",
	HandlerType: (*ParticipantLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ParticipantLayer_Get_Handler,
		},
		{
			MethodName: "TagByID",
			Handler:    _ParticipantLayer_TagByID_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ParticipantLayer_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// RegisterLayerClient is the client API for RegisterLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegisterLayerClient interface {
	Create(ctx context.Context, in *Register, opts ...grpc.CallOption) (*Empty, error)
	GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Register, error)
	Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*RegisterList, error)
}

type registerLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewRegisterLayerClient(cc grpc.ClientConnInterface) RegisterLayerClient {
	return &registerLayerClient{cc}
}

func (c *registerLayerClient) Create(ctx context.Context, in *Register, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.RegisterLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerLayerClient) GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Register, error) {
	out := new(Register)
	err := c.cc.Invoke(ctx, "/layer.RegisterLayer/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerLayerClient) Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.RegisterLayer/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerLayerClient) Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*RegisterList, error) {
	out := new(RegisterList)
	err := c.cc.Invoke(ctx, "/layer.RegisterLayer/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegisterLayerServer is the server API for RegisterLayer service.
// All implementations must embed UnimplementedRegisterLayerServer
// for forward compatibility
type RegisterLayerServer interface {
	Create(context.Context, *Register) (*Empty, error)
	GetByID(context.Context, *IDPayload) (*Register, error)
	Delete(context.Context, *IDPayload) (*Empty, error)
	Get(context.Context, *Pagination) (*RegisterList, error)
	mustEmbedUnimplementedRegisterLayerServer()
}

// UnimplementedRegisterLayerServer must be embedded to have forward compatible implementations.
type UnimplementedRegisterLayerServer struct {
}

func (UnimplementedRegisterLayerServer) Create(context.Context, *Register) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedRegisterLayerServer) GetByID(context.Context, *IDPayload) (*Register, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByID not implemented")
}
func (UnimplementedRegisterLayerServer) Delete(context.Context, *IDPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegisterLayerServer) Get(context.Context, *Pagination) (*RegisterList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegisterLayerServer) mustEmbedUnimplementedRegisterLayerServer() {}

// UnsafeRegisterLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegisterLayerServer will
// result in compilation errors.
type UnsafeRegisterLayerServer interface {
	mustEmbedUnimplementedRegisterLayerServer()
}

func RegisterRegisterLayerServer(s grpc.ServiceRegistrar, srv RegisterLayerServer) {
	s.RegisterService(&RegisterLayer_ServiceDesc, srv)
}

func _RegisterLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Register)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.RegisterLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterLayerServer).Create(ctx, req.(*Register))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegisterLayer_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterLayerServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.RegisterLayer/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterLayerServer).GetByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegisterLayer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterLayerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.RegisterLayer/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterLayerServer).Delete(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegisterLayer_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterLayerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.RegisterLayer/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterLayerServer).Get(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterLayer_ServiceDesc is the grpc.ServiceDesc for RegisterLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegisterLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.RegisterLayer",
	HandlerType: (*RegisterLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _RegisterLayer_Create_Handler,
		},
		{
			MethodName: "GetByID",
			Handler:    _RegisterLayer_GetByID_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegisterLayer_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegisterLayer_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// SubscriptionLayerClient is the client API for SubscriptionLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubscriptionLayerClient interface {
	Create(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*SubscriptionList, error)
	Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error)
	GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Subscription, error)
}

type subscriptionLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscriptionLayerClient(cc grpc.ClientConnInterface) SubscriptionLayerClient {
	return &subscriptionLayerClient{cc}
}

func (c *subscriptionLayerClient) Create(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.SubscriptionLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionLayerClient) Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*SubscriptionList, error) {
	out := new(SubscriptionList)
	err := c.cc.Invoke(ctx, "/layer.SubscriptionLayer/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionLayerClient) Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.SubscriptionLayer/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionLayerClient) GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Subscription, error) {
	out := new(Subscription)
	err := c.cc.Invoke(ctx, "/layer.SubscriptionLayer/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionLayerServer is the server API for SubscriptionLayer service.
// All implementations must embed UnimplementedSubscriptionLayerServer
// for forward compatibility
type SubscriptionLayerServer interface {
	Create(context.Context, *Subscription) (*Empty, error)
	Get(context.Context, *Pagination) (*SubscriptionList, error)
	Delete(context.Context, *IDPayload) (*Empty, error)
	GetByID(context.Context, *IDPayload) (*Subscription, error)
	mustEmbedUnimplementedSubscriptionLayerServer()
}

// UnimplementedSubscriptionLayerServer must be embedded to have forward compatible implementations.
type UnimplementedSubscriptionLayerServer struct {
}

func (UnimplementedSubscriptionLayerServer) Create(context.Context, *Subscription) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedSubscriptionLayerServer) Get(context.Context, *Pagination) (*SubscriptionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSubscriptionLayerServer) Delete(context.Context, *IDPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSubscriptionLayerServer) GetByID(context.Context, *IDPayload) (*Subscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByID not implemented")
}
func (UnimplementedSubscriptionLayerServer) mustEmbedUnimplementedSubscriptionLayerServer() {}

// UnsafeSubscriptionLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscriptionLayerServer will
// result in compilation errors.
type UnsafeSubscriptionLayerServer interface {
	mustEmbedUnimplementedSubscriptionLayerServer()
}

func RegisterSubscriptionLayerServer(s grpc.ServiceRegistrar, srv SubscriptionLayerServer) {
	s.RegisterService(&SubscriptionLayer_ServiceDesc, srv)
}

func _SubscriptionLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.SubscriptionLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionLayerServer).Create(ctx, req.(*Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionLayer_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionLayerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.SubscriptionLayer/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionLayerServer).Get(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionLayer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionLayerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.SubscriptionLayer/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionLayerServer).Delete(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionLayer_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionLayerServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.SubscriptionLayer/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionLayerServer).GetByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

// SubscriptionLayer_ServiceDesc is the grpc.ServiceDesc for SubscriptionLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubscriptionLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.SubscriptionLayer",
	HandlerType: (*SubscriptionLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _SubscriptionLayer_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _SubscriptionLayer_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SubscriptionLayer_Delete_Handler,
		},
		{
			MethodName: "GetByID",
			Handler:    _SubscriptionLayer_GetByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// PaymentLayerClient is the client API for PaymentLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentLayerClient interface {
	GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Payment, error)
	GetByUserID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*PaymentList, error)
	Create(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Empty, error)
}

type paymentLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentLayerClient(cc grpc.ClientConnInterface) PaymentLayerClient {
	return &paymentLayerClient{cc}
}

func (c *paymentLayerClient) GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := c.cc.Invoke(ctx, "/layer.PaymentLayer/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLayerClient) GetByUserID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*PaymentList, error) {
	out := new(PaymentList)
	err := c.cc.Invoke(ctx, "/layer.PaymentLayer/GetByUserID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLayerClient) Create(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.PaymentLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentLayerClient) Delete(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.PaymentLayer/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentLayerServer is the server API for PaymentLayer service.
// All implementations must embed UnimplementedPaymentLayerServer
// for forward compatibility
type PaymentLayerServer interface {
	GetByID(context.Context, *IDPayload) (*Payment, error)
	GetByUserID(context.Context, *IDPayload) (*PaymentList, error)
	Create(context.Context, *Payment) (*Empty, error)
	Delete(context.Context, *Payment) (*Empty, error)
	mustEmbedUnimplementedPaymentLayerServer()
}

// UnimplementedPaymentLayerServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentLayerServer struct {
}

func (UnimplementedPaymentLayerServer) GetByID(context.Context, *IDPayload) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByID not implemented")
}
func (UnimplementedPaymentLayerServer) GetByUserID(context.Context, *IDPayload) (*PaymentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByUserID not implemented")
}
func (UnimplementedPaymentLayerServer) Create(context.Context, *Payment) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPaymentLayerServer) Delete(context.Context, *Payment) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPaymentLayerServer) mustEmbedUnimplementedPaymentLayerServer() {}

// UnsafePaymentLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentLayerServer will
// result in compilation errors.
type UnsafePaymentLayerServer interface {
	mustEmbedUnimplementedPaymentLayerServer()
}

func RegisterPaymentLayerServer(s grpc.ServiceRegistrar, srv PaymentLayerServer) {
	s.RegisterService(&PaymentLayer_ServiceDesc, srv)
}

func _PaymentLayer_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLayerServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.PaymentLayer/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLayerServer).GetByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLayer_GetByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLayerServer).GetByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.PaymentLayer/GetByUserID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLayerServer).GetByUserID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.PaymentLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLayerServer).Create(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentLayer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentLayerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.PaymentLayer/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentLayerServer).Delete(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentLayer_ServiceDesc is the grpc.ServiceDesc for PaymentLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.PaymentLayer",
	HandlerType: (*PaymentLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetByID",
			Handler:    _PaymentLayer_GetByID_Handler,
		},
		{
			MethodName: "GetByUserID",
			Handler:    _PaymentLayer_GetByUserID_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _PaymentLayer_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PaymentLayer_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// CertificateLayerClient is the client API for CertificateLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CertificateLayerClient interface {
	Create(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Empty, error)
	Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*CertificateList, error)
}

type certificateLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewCertificateLayerClient(cc grpc.ClientConnInterface) CertificateLayerClient {
	return &certificateLayerClient{cc}
}

func (c *certificateLayerClient) Create(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.CertificateLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certificateLayerClient) Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*CertificateList, error) {
	out := new(CertificateList)
	err := c.cc.Invoke(ctx, "/layer.CertificateLayer/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertificateLayerServer is the server API for CertificateLayer service.
// All implementations must embed UnimplementedCertificateLayerServer
// for forward compatibility
type CertificateLayerServer interface {
	Create(context.Context, *Certificate) (*Empty, error)
	Get(context.Context, *Pagination) (*CertificateList, error)
	mustEmbedUnimplementedCertificateLayerServer()
}

// UnimplementedCertificateLayerServer must be embedded to have forward compatible implementations.
type UnimplementedCertificateLayerServer struct {
}

func (UnimplementedCertificateLayerServer) Create(context.Context, *Certificate) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCertificateLayerServer) Get(context.Context, *Pagination) (*CertificateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCertificateLayerServer) mustEmbedUnimplementedCertificateLayerServer() {}

// UnsafeCertificateLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CertificateLayerServer will
// result in compilation errors.
type UnsafeCertificateLayerServer interface {
	mustEmbedUnimplementedCertificateLayerServer()
}

func RegisterCertificateLayerServer(s grpc.ServiceRegistrar, srv CertificateLayerServer) {
	s.RegisterService(&CertificateLayer_ServiceDesc, srv)
}

func _CertificateLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Certificate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.CertificateLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateLayerServer).Create(ctx, req.(*Certificate))
	}
	return interceptor(ctx, in, info, handler)
}

func _CertificateLayer_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateLayerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.CertificateLayer/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateLayerServer).Get(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

// CertificateLayer_ServiceDesc is the grpc.ServiceDesc for CertificateLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CertificateLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.CertificateLayer",
	HandlerType: (*CertificateLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CertificateLayer_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CertificateLayer_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// UserLayerClient is the client API for UserLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserLayerClient interface {
	GetByEmail(ctx context.Context, in *EmailPayload, opts ...grpc.CallOption) (*User, error)
	GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*User, error)
	Create(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error)
	Edit(ctx context.Context, in *UserEditPayload, opts ...grpc.CallOption) (*Empty, error)
}

type userLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewUserLayerClient(cc grpc.ClientConnInterface) UserLayerClient {
	return &userLayerClient{cc}
}

func (c *userLayerClient) GetByEmail(ctx context.Context, in *EmailPayload, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/layer.UserLayer/GetByEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLayerClient) GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/layer.UserLayer/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLayerClient) Create(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.UserLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLayerClient) Edit(ctx context.Context, in *UserEditPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.UserLayer/Edit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserLayerServer is the server API for UserLayer service.
// All implementations must embed UnimplementedUserLayerServer
// for forward compatibility
type UserLayerServer interface {
	GetByEmail(context.Context, *EmailPayload) (*User, error)
	GetByID(context.Context, *IDPayload) (*User, error)
	Create(context.Context, *User) (*Empty, error)
	Edit(context.Context, *UserEditPayload) (*Empty, error)
	mustEmbedUnimplementedUserLayerServer()
}

// UnimplementedUserLayerServer must be embedded to have forward compatible implementations.
type UnimplementedUserLayerServer struct {
}

func (UnimplementedUserLayerServer) GetByEmail(context.Context, *EmailPayload) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByEmail not implemented")
}
func (UnimplementedUserLayerServer) GetByID(context.Context, *IDPayload) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByID not implemented")
}
func (UnimplementedUserLayerServer) Create(context.Context, *User) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUserLayerServer) Edit(context.Context, *UserEditPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Edit not implemented")
}
func (UnimplementedUserLayerServer) mustEmbedUnimplementedUserLayerServer() {}

// UnsafeUserLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserLayerServer will
// result in compilation errors.
type UnsafeUserLayerServer interface {
	mustEmbedUnimplementedUserLayerServer()
}

func RegisterUserLayerServer(s grpc.ServiceRegistrar, srv UserLayerServer) {
	s.RegisterService(&UserLayer_ServiceDesc, srv)
}

func _UserLayer_GetByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).GetByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.UserLayer/GetByEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).GetByEmail(ctx, req.(*EmailPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLayer_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.UserLayer/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).GetByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.UserLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).Create(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLayer_Edit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEditPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).Edit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.UserLayer/Edit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).Edit(ctx, req.(*UserEditPayload))
	}
	return interceptor(ctx, in, info, handler)
}

// UserLayer_ServiceDesc is the grpc.ServiceDesc for UserLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.UserLayer",
	HandlerType: (*UserLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetByEmail",
			Handler:    _UserLayer_GetByEmail_Handler,
		},
		{
			MethodName: "GetByID",
			Handler:    _UserLayer_GetByID_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _UserLayer_Create_Handler,
		},
		{
			MethodName: "Edit",
			Handler:    _UserLayer_Edit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}

// LikeLayerClient is the client API for LikeLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LikeLayerClient interface {
	Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*LikeList, error)
	Create(ctx context.Context, in *Like, opts ...grpc.CallOption) (*Empty, error)
	Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error)
	GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Like, error)
}

type likeLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewLikeLayerClient(cc grpc.ClientConnInterface) LikeLayerClient {
	return &likeLayerClient{cc}
}

func (c *likeLayerClient) Get(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*LikeList, error) {
	out := new(LikeList)
	err := c.cc.Invoke(ctx, "/layer.LikeLayer/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeLayerClient) Create(ctx context.Context, in *Like, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.LikeLayer/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeLayerClient) Delete(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/layer.LikeLayer/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *likeLayerClient) GetByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Like, error) {
	out := new(Like)
	err := c.cc.Invoke(ctx, "/layer.LikeLayer/GetByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LikeLayerServer is the server API for LikeLayer service.
// All implementations must embed UnimplementedLikeLayerServer
// for forward compatibility
type LikeLayerServer interface {
	Get(context.Context, *Pagination) (*LikeList, error)
	Create(context.Context, *Like) (*Empty, error)
	Delete(context.Context, *IDPayload) (*Empty, error)
	GetByID(context.Context, *IDPayload) (*Like, error)
	mustEmbedUnimplementedLikeLayerServer()
}

// UnimplementedLikeLayerServer must be embedded to have forward compatible implementations.
type UnimplementedLikeLayerServer struct {
}

func (UnimplementedLikeLayerServer) Get(context.Context, *Pagination) (*LikeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLikeLayerServer) Create(context.Context, *Like) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLikeLayerServer) Delete(context.Context, *IDPayload) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLikeLayerServer) GetByID(context.Context, *IDPayload) (*Like, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByID not implemented")
}
func (UnimplementedLikeLayerServer) mustEmbedUnimplementedLikeLayerServer() {}

// UnsafeLikeLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LikeLayerServer will
// result in compilation errors.
type UnsafeLikeLayerServer interface {
	mustEmbedUnimplementedLikeLayerServer()
}

func RegisterLikeLayerServer(s grpc.ServiceRegistrar, srv LikeLayerServer) {
	s.RegisterService(&LikeLayer_ServiceDesc, srv)
}

func _LikeLayer_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeLayerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.LikeLayer/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeLayerServer).Get(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _LikeLayer_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Like)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeLayerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.LikeLayer/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeLayerServer).Create(ctx, req.(*Like))
	}
	return interceptor(ctx, in, info, handler)
}

func _LikeLayer_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeLayerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.LikeLayer/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeLayerServer).Delete(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _LikeLayer_GetByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LikeLayerServer).GetByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/layer.LikeLayer/GetByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LikeLayerServer).GetByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

// LikeLayer_ServiceDesc is the grpc.ServiceDesc for LikeLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LikeLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "layer.LikeLayer",
	HandlerType: (*LikeLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _LikeLayer_Get_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _LikeLayer_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LikeLayer_Delete_Handler,
		},
		{
			MethodName: "GetByID",
			Handler:    _LikeLayer_GetByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "layer/goevent.proto",
}
