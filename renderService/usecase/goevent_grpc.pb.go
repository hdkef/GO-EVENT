// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.15.8
// source: usecase/goevent.proto

package usecase

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EventLayerClient is the client API for EventLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventLayerClient interface {
	GetAllParticipant(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*ParticipantList, error)
	GetAllEvent(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*EventList, error)
	GetEventByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Event, error)
	RegisterEvent(ctx context.Context, in *Register, opts ...grpc.CallOption) (*Empty, error)
	GetRegisterByUserID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Register, error)
	CreateSubscription(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error)
	GetAllSubscription(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*SubscriptionList, error)
	GetPaymentByUserID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*PaymentList, error)
	CreatePayment(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Empty, error)
}

type eventLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewEventLayerClient(cc grpc.ClientConnInterface) EventLayerClient {
	return &eventLayerClient{cc}
}

func (c *eventLayerClient) GetAllParticipant(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*ParticipantList, error) {
	out := new(ParticipantList)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/GetAllParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) GetAllEvent(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*EventList, error) {
	out := new(EventList)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/GetAllEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) GetEventByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/GetEventByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) RegisterEvent(ctx context.Context, in *Register, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/RegisterEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) GetRegisterByUserID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*Register, error) {
	out := new(Register)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/GetRegisterByUserID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) CreateSubscription(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/CreateSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) GetAllSubscription(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (*SubscriptionList, error) {
	out := new(SubscriptionList)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/GetAllSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) GetPaymentByUserID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*PaymentList, error) {
	out := new(PaymentList)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/GetPaymentByUserID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventLayerClient) CreatePayment(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/usecase.EventLayer/CreatePayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventLayerServer is the server API for EventLayer service.
// All implementations must embed UnimplementedEventLayerServer
// for forward compatibility
type EventLayerServer interface {
	GetAllParticipant(context.Context, *Pagination) (*ParticipantList, error)
	GetAllEvent(context.Context, *Pagination) (*EventList, error)
	GetEventByID(context.Context, *IDPayload) (*Event, error)
	RegisterEvent(context.Context, *Register) (*Empty, error)
	GetRegisterByUserID(context.Context, *IDPayload) (*Register, error)
	CreateSubscription(context.Context, *Subscription) (*Empty, error)
	GetAllSubscription(context.Context, *Pagination) (*SubscriptionList, error)
	GetPaymentByUserID(context.Context, *IDPayload) (*PaymentList, error)
	CreatePayment(context.Context, *Payment) (*Empty, error)
	mustEmbedUnimplementedEventLayerServer()
}

// UnimplementedEventLayerServer must be embedded to have forward compatible implementations.
type UnimplementedEventLayerServer struct {
}

func (UnimplementedEventLayerServer) GetAllParticipant(context.Context, *Pagination) (*ParticipantList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllParticipant not implemented")
}
func (UnimplementedEventLayerServer) GetAllEvent(context.Context, *Pagination) (*EventList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllEvent not implemented")
}
func (UnimplementedEventLayerServer) GetEventByID(context.Context, *IDPayload) (*Event, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEventByID not implemented")
}
func (UnimplementedEventLayerServer) RegisterEvent(context.Context, *Register) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterEvent not implemented")
}
func (UnimplementedEventLayerServer) GetRegisterByUserID(context.Context, *IDPayload) (*Register, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisterByUserID not implemented")
}
func (UnimplementedEventLayerServer) CreateSubscription(context.Context, *Subscription) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubscription not implemented")
}
func (UnimplementedEventLayerServer) GetAllSubscription(context.Context, *Pagination) (*SubscriptionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSubscription not implemented")
}
func (UnimplementedEventLayerServer) GetPaymentByUserID(context.Context, *IDPayload) (*PaymentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentByUserID not implemented")
}
func (UnimplementedEventLayerServer) CreatePayment(context.Context, *Payment) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePayment not implemented")
}
func (UnimplementedEventLayerServer) mustEmbedUnimplementedEventLayerServer() {}

// UnsafeEventLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventLayerServer will
// result in compilation errors.
type UnsafeEventLayerServer interface {
	mustEmbedUnimplementedEventLayerServer()
}

func RegisterEventLayerServer(s grpc.ServiceRegistrar, srv EventLayerServer) {
	s.RegisterService(&EventLayer_ServiceDesc, srv)
}

func _EventLayer_GetAllParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetAllParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/GetAllParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetAllParticipant(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_GetAllEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetAllEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/GetAllEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetAllEvent(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_GetEventByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetEventByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/GetEventByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetEventByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_RegisterEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Register)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).RegisterEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/RegisterEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).RegisterEvent(ctx, req.(*Register))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_GetRegisterByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetRegisterByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/GetRegisterByUserID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetRegisterByUserID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).CreateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/CreateSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).CreateSubscription(ctx, req.(*Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_GetAllSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagination)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetAllSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/GetAllSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetAllSubscription(ctx, req.(*Pagination))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_GetPaymentByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).GetPaymentByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/GetPaymentByUserID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).GetPaymentByUserID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventLayer_CreatePayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventLayerServer).CreatePayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.EventLayer/CreatePayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventLayerServer).CreatePayment(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

// EventLayer_ServiceDesc is the grpc.ServiceDesc for EventLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "usecase.EventLayer",
	HandlerType: (*EventLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllParticipant",
			Handler:    _EventLayer_GetAllParticipant_Handler,
		},
		{
			MethodName: "GetAllEvent",
			Handler:    _EventLayer_GetAllEvent_Handler,
		},
		{
			MethodName: "GetEventByID",
			Handler:    _EventLayer_GetEventByID_Handler,
		},
		{
			MethodName: "RegisterEvent",
			Handler:    _EventLayer_RegisterEvent_Handler,
		},
		{
			MethodName: "GetRegisterByUserID",
			Handler:    _EventLayer_GetRegisterByUserID_Handler,
		},
		{
			MethodName: "CreateSubscription",
			Handler:    _EventLayer_CreateSubscription_Handler,
		},
		{
			MethodName: "GetAllSubscription",
			Handler:    _EventLayer_GetAllSubscription_Handler,
		},
		{
			MethodName: "GetPaymentByUserID",
			Handler:    _EventLayer_GetPaymentByUserID_Handler,
		},
		{
			MethodName: "CreatePayment",
			Handler:    _EventLayer_CreatePayment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usecase/goevent.proto",
}

// UserLayerClient is the client API for UserLayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserLayerClient interface {
	Login(ctx context.Context, in *LoginPayload, opts ...grpc.CallOption) (*Token, error)
	GetUserByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*User, error)
	Register(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error)
}

type userLayerClient struct {
	cc grpc.ClientConnInterface
}

func NewUserLayerClient(cc grpc.ClientConnInterface) UserLayerClient {
	return &userLayerClient{cc}
}

func (c *userLayerClient) Login(ctx context.Context, in *LoginPayload, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := c.cc.Invoke(ctx, "/usecase.UserLayer/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLayerClient) GetUserByID(ctx context.Context, in *IDPayload, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/usecase.UserLayer/GetUserByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLayerClient) Register(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/usecase.UserLayer/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserLayerServer is the server API for UserLayer service.
// All implementations must embed UnimplementedUserLayerServer
// for forward compatibility
type UserLayerServer interface {
	Login(context.Context, *LoginPayload) (*Token, error)
	GetUserByID(context.Context, *IDPayload) (*User, error)
	Register(context.Context, *User) (*Empty, error)
	mustEmbedUnimplementedUserLayerServer()
}

// UnimplementedUserLayerServer must be embedded to have forward compatible implementations.
type UnimplementedUserLayerServer struct {
}

func (UnimplementedUserLayerServer) Login(context.Context, *LoginPayload) (*Token, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserLayerServer) GetUserByID(context.Context, *IDPayload) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByID not implemented")
}
func (UnimplementedUserLayerServer) Register(context.Context, *User) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserLayerServer) mustEmbedUnimplementedUserLayerServer() {}

// UnsafeUserLayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserLayerServer will
// result in compilation errors.
type UnsafeUserLayerServer interface {
	mustEmbedUnimplementedUserLayerServer()
}

func RegisterUserLayerServer(s grpc.ServiceRegistrar, srv UserLayerServer) {
	s.RegisterService(&UserLayer_ServiceDesc, srv)
}

func _UserLayer_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.UserLayer/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).Login(ctx, req.(*LoginPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLayer_GetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).GetUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.UserLayer/GetUserByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).GetUserByID(ctx, req.(*IDPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLayer_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLayerServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/usecase.UserLayer/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLayerServer).Register(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

// UserLayer_ServiceDesc is the grpc.ServiceDesc for UserLayer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserLayer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "usecase.UserLayer",
	HandlerType: (*UserLayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserLayer_Login_Handler,
		},
		{
			MethodName: "GetUserByID",
			Handler:    _UserLayer_GetUserByID_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _UserLayer_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usecase/goevent.proto",
}
